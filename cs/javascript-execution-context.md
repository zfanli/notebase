---
type: JavaScript
tags: JavaScript QoK-D
---

# 执行上下文 Execution Context

执行上下文分两个阶段：

1. 创建内存
   1. 创建全局对象（window or global）
   2. 创建 `this` 关键字绑定给全局对象
   3. 准备内存堆储存变量和函数引用
   4. 在全局执行上下文储存函数和变量并且设置为 `undefined`
      1. 对函数来说，创建阶段会创建并保存完整的函数代码
      2. 对变量来说，创建阶段会创建变量的名称，并赋值为 `undefined`
2. 执行阶段
   1. 逐行执行
   2. 给每个函数调用创建新的执行上下文

## 提升 Hoisting

从执行上下文工作的方式可以看出，变量提升发生在创建内存阶段。也就是说在真正执行代码之前，所有声明的变量和函数会被识别出来，并且在对应的作用域创建内存地址。

对于函数来说，创建过程会储存完整的函数代码；对于变量来说，则只会创建对应的内存空间，对应的值为 `undefined`，因为实际的值会在代码逐行执行的过程中被分配给对应的变量。

### `let` 和 `const`

`let` 和 `const` 同样存在变量提升，不同之处在于提升的作用域差异。

`var` 和 `function` 会在全局或局部作用域被提升，你可以在定义变量或函数之前访问它们。

但是 `let` 和 `const` 会在 block 作用域提升，并且对访问时机做出限制，在初始化它们之前进行访问会抛出尚未初始化的异常。换言之，相对 `var` 来说，`let` 和 `const` 在内存中创建变量名称之后，并没有给变量赋予 `undefined` 初始值，造成“临时死区”，让变量无法访问。
